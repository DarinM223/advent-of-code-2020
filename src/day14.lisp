(defpackage day14
  (:use :cl :iterate :utils)
  (:import-from :trivia))
(in-package :day14)

(defparameter *input*
  (with-open-file (stream (relative-path #P"resources/day14.txt"))
    (iter (for line in-lines stream)
      (for (var value) = (uiop:split-string line :separator "="))
      (for trimmed-var = (string-right-trim " ]" var))
      (collect (list trimmed-var
                     (if (string= trimmed-var "mask")
                         (string-left-trim " " value)
                         (parse-integer value)))))))

(defun pad-string (s1 s2)
  (let* ((str-diff (write-to-string (max (length s1) (length s2))))
         (format-string (concatenate 'string "~" str-diff ",,,'0@a")))
    (if (>= (length s1) (length s2))
        (values s1 (format nil format-string s2))
        (values (format nil format-string s1) s2))))

(defun apply-mask (num mask)
  (multiple-value-bind (mask num-binary)
      (pad-string mask (write-to-string num :base 2))
    (iter (for ch in-string mask with-index i)
      (cond ((char= ch #\1) (setf (char num-binary i) #\1))
            ((char= ch #\0) (setf (char num-binary i) #\0)))
      (finally (return (parse-integer num-binary :radix 2))))))

(defun run-instructions (input)
  (iter (with mask = nil)
    (for (lvalue rvalue) in input)
    (if (string= (subseq lvalue 0 4) "mask")
        (setf mask rvalue)
        (let ((lvalue (parse-integer (subseq lvalue 4)))
              (rvalue (apply-mask rvalue mask)))
          (collect lvalue => rvalue)))))

(defun address-combinations (binary)
  (iter (for ch in-string binary with-index i)
    (when (char= ch #\X)
      (let ((s1 (copy-seq binary))
            (s2 (copy-seq binary)))
        (setf (char s1 i) #\0)
        (setf (char s2 i) #\1)
        (return (append (address-combinations s1)
                        (address-combinations s2)))))
    (finally (return (list binary)))))

(defun ch-or (ch1 ch2)
  (trivia:match (list ch1 ch2)
    ((list #\1 #\1) #\1)
    ((list #\1 #\0) #\1)
    ((list #\0 #\1) #\1)
    ((list #\0 #\0) #\0)))

(defun apply-mask2 (num mask)
  (multiple-value-bind (mask num-binary)
      (pad-string mask (write-to-string num :base 2))
    (iter (for mask-ch in-string mask with-index i)
      (for num-ch = (aref num-binary i))
      (cond ((char= mask-ch #\X) (setf (char num-binary i) mask-ch))
            (t (setf (char num-binary i) (ch-or num-ch mask-ch))))
      (finally (return (mapcar (lambda (s) (parse-integer s :radix 2))
                               (address-combinations num-binary)))))))

(defun run-instructions2 (input)
  (iter outer
    (with mask = nil)
    (for (lvalue rvalue) in input)
    (if (string= (subseq lvalue 0 4) "mask")
        (setf mask rvalue)
        (let* ((indexes (apply-mask2 (parse-integer (subseq lvalue 4))
                                     mask)))
          (iter (for i in indexes) (in outer (collect i => rvalue)))))))

(defparameter *part1*
  (iter (for (k v) in-hashtable (run-instructions *input*))
    (summing v)))
(defparameter *part2*
  (iter (for (k v) in-hashtable (run-instructions2 *input*))
    (summing v)))
